<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Nacos基本原理（一） | Lavigne-yang.Blog</title><meta name="author" content="Lavigne-yang"><meta name="copyright" content="Lavigne-yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="重点关注naming&#x2F;config模块、基于plugin模块开发自定义插件（如数据源适配）、扩展core模块的通信框架（gRPC&#x2F;HTTP）    版本 默认协议 特点 配置方式    1.x HTTP 短连接，性能低 无需额外配置   2.x gRPC 长连接，性能提升 10 倍 临时实例自动启用（ephemeral&#x3D;true）   3.x gRPC + QUIC 支持 AI">
<meta property="og:type" content="article">
<meta property="og:title" content="Nacos基本原理（一）">
<meta property="og:url" content="https://lavyoung.github.io/2025/06/09/Nacos%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="Lavigne-yang.Blog">
<meta property="og:description" content="重点关注naming&#x2F;config模块、基于plugin模块开发自定义插件（如数据源适配）、扩展core模块的通信框架（gRPC&#x2F;HTTP）    版本 默认协议 特点 配置方式    1.x HTTP 短连接，性能低 无需额外配置   2.x gRPC 长连接，性能提升 10 倍 临时实例自动启用（ephemeral&#x3D;true）   3.x gRPC + QUIC 支持 AI">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lavyoung.github.io/img/article/nasa_the_blue_marble.jpg">
<meta property="article:published_time" content="2025-06-09T12:14:21.000Z">
<meta property="article:modified_time" content="2025-06-25T11:21:39.012Z">
<meta property="article:author" content="Lavigne-yang">
<meta property="article:tag" content="Nacos">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lavyoung.github.io/img/article/nasa_the_blue_marble.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Nacos基本原理（一）",
  "url": "https://lavyoung.github.io/2025/06/09/Nacos%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/",
  "image": "https://lavyoung.github.io/img/article/nasa_the_blue_marble.jpg",
  "datePublished": "2025-06-09T12:14:21.000Z",
  "dateModified": "2025-06-25T11:21:39.012Z",
  "author": [
    {
      "@type": "Person",
      "name": "Lavigne-yang",
      "url": "https://lavyoung.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/blog-black.svg"><link rel="canonical" href="https://lavyoung.github.io/2025/06/09/Nacos%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Nacos基本原理（一）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/top_img.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/article/nasa_the_blue_marble.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/blog-black.svg" alt="Logo"><span class="site-name">Lavigne-yang.Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Nacos基本原理（一）</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Nacos基本原理（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-09T12:14:21.000Z" title="发表于 2025-06-09 20:14:21">2025-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-25T11:21:39.012Z" title="更新于 2025-06-25 19:21:39">2025-06-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>重点关注<code>naming</code>&#x2F;<code>config</code>模块、基于<code>plugin</code>模块开发自定义插件（如数据源适配）、扩展<code>core</code>模块的通信框架（gRPC&#x2F;HTTP）</p>
<table>
<thead>
<tr>
<th><strong>版本</strong></th>
<th><strong>默认协议</strong></th>
<th><strong>特点</strong></th>
<th><strong>配置方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1.x</strong></td>
<td>HTTP</td>
<td>短连接，性能低</td>
<td>无需额外配置</td>
</tr>
<tr>
<td><strong>2.x</strong></td>
<td><strong>gRPC</strong></td>
<td>长连接，性能提升 10 倍</td>
<td>临时实例自动启用（<code>ephemeral=true</code>）</td>
</tr>
<tr>
<td><strong>3.x</strong></td>
<td>gRPC + QUIC</td>
<td>支持 AI Agent 场景，强化安全隔离</td>
<td>默认启用，可通过插件扩展协议</td>
</tr>
</tbody></table>
<p><strong>关键版本升级点:</strong></p>
<p>2.0</p>
<ul>
<li>gRPC 替代 HTTP 提升吞吐量。</li>
<li>插件化架构（如自定义鉴权模块）</li>
</ul>
<p>3.0 </p>
<ul>
<li><strong>安全增强</strong>：分离控制台 API 与服务 API 端口，支持命名空间统一管理</li>
<li><strong>AI 支持</strong>：优化轻量化 Agent 的注册发现机制（如 Serverless 场景）</li>
</ul>
<h2 id="服务注册和发现（健康检查）"><a href="#服务注册和发现（健康检查）" class="headerlink" title="服务注册和发现（健康检查）"></a>服务注册和发现（健康检查）</h2><h3 id="服务注册机制"><a href="#服务注册机制" class="headerlink" title="服务注册机制"></a>服务注册机制</h3><ol>
<li><strong>客户端自动注册触发机制</strong></li>
</ol>
<ul>
<li><strong>入口</strong>：Spring Boot 项目引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 后，通过 <code>spring.factories</code> 加载自动配置类 <code>NacosServiceRegistryAutoConfiguration</code>。</li>
<li><strong>关键 Bean</strong>：<ul>
<li><code>NacosServiceRegistry</code>：实现 <code>ServiceRegistry</code> 接口，负责注册逻辑。</li>
<li><code>NacosRegistration</code>：封装实例信息（IP、端口、服务名）。</li>
<li><code>NacosAutoServiceRegistration</code>：继承 <code>AbstractAutoServiceRegistration</code>，监听 <strong><code>WebServerInitializedEvent</code></strong> 事件（Web 服务启动完成后触发注册）</li>
</ul>
</li>
<li><strong>事件触发源码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoServiceRegistration.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> &#123;</span><br><span class="line">    bind(event);<span class="comment">// 绑定事件 → 调用 start() → 调用 register()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.serviceRegistry.register(getRegistration());<span class="comment">// 调用 NacosServiceRegistry</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>注册请求发起关键源码</strong></li>
</ol>
<ul>
<li><strong>组装实例信息</strong></li>
</ul>
<p><code>NacosServiceRegistry#register()</code> 将 Spring 的 <code>Registration</code> 对象转为 Nacos 的 <code>Instance</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Registration registration)</span> &#123;</span><br><span class="line">    <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> getNacosInstanceFromRegistration(registration);</span><br><span class="line">    namingService.registerInstance(serviceId, group, instance);<span class="comment">// 调用 NamingService</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>协议选择与请求发送（版本差异重点）</strong></li>
</ul>
<p><strong><code>NamingService#registerInstance()</code></strong> 的实现类 <code>NacosNamingService</code> 根据<strong>实例类型</strong>选择协议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerInstance</span><span class="params">(String serviceName, String groupName, Instance instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为临时实例（默认为 true）</span></span><br><span class="line">    <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">        <span class="type">BeatInfo</span> <span class="variable">beatInfo</span> <span class="operator">=</span> buildBeatInfo(groupedServiceName, instance); <span class="comment">// 构建心跳信息</span></span><br><span class="line">        beatReactor.addBeatInfo(groupedServiceName, beatInfo); <span class="comment">// 启动心跳线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择协议客户端：临时实例用 gRPC，持久实例用 HTTP</span></span><br><span class="line">    clientProxy.registerService(serviceName, groupName, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>协议选择逻辑</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NamingClientProxy <span class="title function_">getExecuteClientProxy</span><span class="params">(Instance instance)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.isEphemeral() ? grpcClientProxy : httpClientProxy; <span class="comment">// 临时实例 → gRPC；持久实例 → HTTP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>协议主动切换</strong></p>
<p>  <em><strong>客户端配置</strong></em>：Nacos客户端通过配置参数明确指定协议类型，优先级高于默认行为：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HTTP协议配置 Spring Cloud Alibaba项目</span><br><span class="line">spring.cloud.nacos.discovery.protocol=http  # 服务发现协议</span><br><span class="line">spring.cloud.nacos.config.protocol=http     # 配置管理协议</span><br><span class="line"></span><br><span class="line">gRPC协议配置（<span class="number">2.</span>x默认）</span><br><span class="line">spring.cloud.nacos.discovery.protocol=grpc</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>协议底层实现逻辑</strong></p>
<p>  Nacos客户端封装了协议适配层，通过工厂模式动态创建协议处理器：</p>
<ul>
<li><strong>客户端初始化流程</strong>：<ol>
<li>解析配置参数（如<code>protocol=http</code>）。</li>
<li>通过<code>ProtocolManager</code>工厂创建<code>NamingClientProxy</code>实例（<code>HttpClientProxy</code>或<code>GrpcClientProxy</code>）。</li>
<li>所有请求（注册、心跳、查询）交由协议代理类处理。</li>
</ol>
</li>
</ul>
<p>  <strong>3. 服务端兼容性</strong></p>
<ul>
<li><strong>HTTP&#x2F;gRPC双端口监听</strong>：<ul>
<li><strong>HTTP</strong>：默认端口<code>8848</code>，兼容1.x客户端。网络策略禁止长连接（如某些安全组规则），兼容旧基础设施（如HTTP代理）</li>
<li><strong>gRPC</strong>：默认端口<code>9848</code>（<code>8848+1000</code>），供2.x客户端使用。<strong>gRPC优势</strong>：长连接、多路复用，吞吐量提升50%+，适合高并发场景<strong>5</strong></li>
</ul>
</li>
<li><strong>服务端协议识别</strong>：根据请求端口和协议头自动路由到对应处理模块，无需额外配置</li>
</ul>
</li>
<li><p><strong>服务端兼容性</strong></p>
</li>
</ul>
<ol>
<li><strong>服务端处理流程</strong></li>
</ol>
<ul>
<li><strong>请求入口</strong></li>
</ul>
<p>服务注册请求由 <code>InstanceController</code> 处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制</span><br><span class="line"><span class="meta">@PostMapping(&quot;/instance&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceId</span> <span class="operator">=</span> getNamespaceId(request);<span class="comment">// 获取命名空间Instance instance = parseInstance(request);// 解析实例信息</span></span><br><span class="line">    serviceManager.registerInstance(namespaceId, serviceName, instance);<span class="comment">// 注册实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注册表存储结构</strong></li>
</ul>
<p>服务端使用双层<code>ConcurrentHashMap</code>存储注册信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Map&lt;namespace, Map&lt;group::serviceName, Service&gt;&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;String, Service&gt;&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Service 对象</strong>：包含集群列表（<code>Cluster</code>），每个集群维护实例列表（<code>Instance</code>）</li>
</ul>
<aside>
💡

<ul>
<li><strong>服务端双层 Map 存储</strong>（<code>namespace → serviceName → Instance</code>）</li>
<li><strong>协议动态选择</strong>（临时实例 gRPC &#x2F; 持久实例 HTTP）</aside></li>
</ul>
<p><strong>配置说明：</strong></p>
<p>临时实例：将<code>Instance</code>加入内存注册表 (<code>ConcurrentHashMap&lt;String, Service&gt;</code>结构)。实例启动后台<strong>心跳检查线程池</strong>。Server <strong>不会</strong>主动持久化到数据库</p>
<ul>
<li>Client 端定期（默认5秒）向 Server 发送<strong>HTTP PUT</strong><code>/nacos/v1/ns/instance/beat</code>心跳包，包含自身<code>Instance</code>ID</li>
<li>Server 端 (<code>DistroConsistencyServiceImpl</code>) 收到心跳，更新内存注册表中对应<code>Instance</code>的 <strong><code>lastBeat</code>(最后心跳时间戳)</strong></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">http</span> <span class="comment"># 强制HTTP协议</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">true</span>   <span class="comment"># 默认 true，使用 gRPC</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure>

<p>持久实例：将 <code>Instance</code> 信息<strong>同步写入数据库</strong>（MySQL等）。Server <strong>依赖客户端</strong>显式调用注销接口 (<code>Deregister</code>) 或<strong>配置的主动健康检查机制</strong>（如TCP&#x2F;HTTP&#x2F;Mysql探活）来移除</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span>  <span class="comment"># 使用 HTTP</span></span><br><span class="line">        <span class="attr">heart-beat-interval:</span> <span class="number">30000</span> <span class="comment"># 心跳间隔（毫秒）</span></span><br></pre></td></tr></table></figure>

<h3 id="服务发现流程"><a href="#服务发现流程" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><p>核心的naming模块</p>
<ol>
<li>消费者<code>NacosNamingService</code>通过<code>getInstances(serviceName)</code>获取服务实例列表。首次调用会同步拉取全量<code>ServiceInfo</code> <strong>触发订阅</strong></li>
<li><strong>订阅触发：</strong> Client 发起 <strong>HTTP POST</strong><code>/nacos/v1/ns/instance/list</code>请求订阅指定服务(<code>serviceName</code>)；</li>
<li><strong>Server 端推送机制：</strong><ul>
<li><strong>UDP 优先 (默认)：</strong> Server 监听到注册表变更（新注册、心跳超时、注销）时，会<strong>立即生成一个携带变更 Service 名称的任务，放入异步队列</strong>。处理线程<strong>向所有订阅了该 Service 的 Client 目标 UDP 端口 (默认:端口偏移量1000)</strong> 发送变更通知 (<code>ServiceInfo</code> 摘要信息)。</li>
<li><strong>HTTP 兜底 (Pull)：</strong> Client 端后台维护一个<strong>定时任务（默认每10秒执行一次 -<code>pushReceiverTask</code>）</strong>，主动发起<strong>HTTP GET</strong> <code>/nacos/v1/ns/instance/list</code> 拉取最新 <code>ServiceInfo</code>。</li>
<li><strong>混合模式：</strong> <strong>UDP通知极速触发</strong>拉取（Client收到UDP通知后立即发起一次HTTP拉取），<strong>HTTP长轮询兜底</strong>保证可靠性。<code>pushEmptyProtection</code> (默认<code>true</code>) 是一个<strong>关键容错参数</strong>：当Service下所有实例因故被移除（非正常下线），Server会返回包含 <code>&quot;instances&quot;: []</code> 的空列表给Client，防止Client因接收不到UDP通知而误判无可用实例（旧缓存数据），触发Client本地缓存清理。<em>示例：一个Service因网络分区所有实例被Server误剔，若无此参数，Consumer仍持有旧缓存可能调用失败；设置后，Consumer会收到空列表，清缓存，避免调用无效节点。</em></li>
</ul>
</li>
<li><strong>动态感知实例下线 (Consumer)</strong><ul>
<li><strong>心跳超时移除：</strong> Server端的心跳检查任务 (<code>ClientBeatCheckTask</code>) <strong>定期(默认15秒扫描间隔，阈值20秒超时)</strong> 检查内存注册表中所有临时实例的 <code>lastBeat</code>。若当前时间 - <code>lastBeat &gt; 心跳超时时间(默认15s)</code>，则将其健康状态标记为 <code>false</code>，并在<strong>后续一次扫描(默认15s后)</strong> 如果仍未收到心跳，则将其从注册表中移除。<strong>移除动作立即触发变更通知(UDP)</strong>。</li>
<li><strong>主动注销 (Provider)：</strong> Provider 关闭前主动调用<code>deregisterInstance()</code>，发送 <strong>HTTP DELETE</strong> <code>/nacos/v1/ns/instance</code>。Server 移除实例，<strong>立即触发变更通知(UDP)</strong>。</li>
<li><strong>Consumer:</strong><ul>
<li>收到 <strong>UDP 变更通知</strong>，<strong>立即发起一次 HTTP 请求</strong> 拉取最新 <code>ServiceInfo</code>，更新本地缓存和负载均衡器。</li>
<li><strong>HTTP 兜底轮询(默认10秒)</strong> 也会拉取最新信息更新缓存。</li>
<li>结合 <strong><code>ServiceInfo</code> 中的 <code>hosts</code> 列表（当前健康实例）</strong> 和本地监听器回调（<code>EventNotifier</code>），Ribbon等负载均衡组件能<strong>快速切换可用实例</strong>。<em>典型场景：某个Provider实例所在机器宕机导致心跳停止，约20+15&#x3D;35秒（理论最坏情况，实践中UDP通知能大幅缩短）内，Consumer将感知到该实例不可用并从负载均衡器中摘除</em></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><ul>
<li><strong>临时实例（Ephemeral）</strong>：客户端每 <strong>5 秒</strong>发送心跳，服务端若 <strong>15 秒</strong>未收到心跳标记为不健康，<strong>30 秒</strong>未收到则剔除。(动态扩缩容场景（如秒杀活动），默认通过客户端心跳上报)</li>
<li><strong>持久实例（Persistent）</strong>：服务端主动发起 <strong>HTTP 健康检查</strong>。（常备服务（如数据库主节点），通过服务端主动探测）</li>
<li>临时实例先注册后启动心跳，避免服务端未收到心跳误剔除</li>
</ul>
<p>健康检查线程调度池</p>
<ol>
<li><p><strong>临时实例的健康检查（客户端心跳上报）</strong></p>
<ul>
<li><strong>流程原理</strong><ul>
<li><strong>注册与心跳启动</strong>：服务启动时向Nacos注册，成功后启动后台线程（<code>BeatReactor</code>）定期发送心跳包。<strong>心跳周期</strong>：默认5秒（可通过<code>spring.cloud.nacos.discovery.heart-beat-interval</code>调整）。</li>
<li><strong>服务端状态判断</strong>：<strong>15秒未收到心跳</strong>（如连续3次丢失）：标记实例为<strong>不健康</strong>（<code>healthy=false</code>）。<strong>30秒未收到心跳</strong>：从注册表移除实例。</li>
<li><strong>心跳包内容</strong>：HTTP请求：<code>PUT /nacos/v1/ns/instance/beat?serviceName=xxx&amp;ip=xxx&amp;port=xxx</code></li>
<li><strong>特点</strong>：<ul>
<li>优点：轻量级（客户端主动上报，服务端压力小）、响应快（秒级感知故障）;</li>
<li>缺点：若客户端进程假死（仍能发送心跳），服务端无法感知真实状态；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>持久实例的健康检查（服务端主动探测）</strong></p>
<p> <strong>流程原理</strong></p>
<ul>
<li><p><strong>探测触发</strong>：Nacos服务端启动定时任务，按配置协议主动探测实例。</p>
</li>
<li><p><strong>探测周期</strong>：2000毫秒 + 随机延迟（&lt;5000毫秒）。</p>
</li>
<li><p><strong>探测协议与逻辑</strong>：<strong>TCP探测</strong>：尝试与实例的IP:端口建立TCP连接，成功即视为健康。<strong>HTTP探测</strong>：发送GET&#x2F;POST请求，检查返回状态码是否为2xx（如200）。<strong>MySQL探测</strong>：执行简单SQL（如<code>SELECT 1</code>），验证数据库可访问性。</p>
</li>
<li><p><strong>状态更新</strong>：探测失败时标记实例为不健康，但<strong>不会立即删除</strong>（需手动剔除）</p>
</li>
<li><p><strong>配置方式</strong>:  支持元数据（metadata）指定探测参数</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">checkType:</span> <span class="string">&quot;HTTP&quot;</span>       <span class="comment"># 协议类型（HTTP/TCP/MySQL）</span></span><br><span class="line">  <span class="attr">checkPort:</span> <span class="string">&quot;8080&quot;</span>       <span class="comment"># 探测端口（默认实例端口）</span></span><br><span class="line">  <span class="attr">checkPath:</span> <span class="string">&quot;/health&quot;</span>    <span class="comment"># HTTP探测路径</span></span><br><span class="line">  <span class="attr">expectedResponseCode:</span> <span class="string">&quot;200&quot;</span> <span class="comment"># 期望HTTP状态码</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>集群模式下的健康检查同步</strong></p>
<p> <strong>主节点负责制</strong>：每个服务由集群中一个主节点（Leader）负责健康检查；临时实例：主节点接受心跳后，同步状态给其他节点；持久实例：主节点探测后同步结果，数据一致性，Raft协议等等</p>
<p> <strong>自我保护机制</strong>：设置保护阈值（0 ~ 1，默认0.8）： 当健康实例占比低于阈值时，<strong>继续向不健康实例路由流量</strong>，避免剩余实例被压垮（牺牲部分请求保整体可用）；</p>
<p> <strong>参数调优建议</strong>：缩短心跳间隔（如<code>heart-beat-interval=1s</code>）以加速故障感知，减少探测频率（如<code>interval-ms=10000</code>）以降低服务端压力。</p>
<p> <strong>协议选择场景</strong>：需验证业务接口可用性（如Spring Boot Actuator的<code>/actuator/health</code>），仅验证网络连通性，开销最小</p>
</li>
</ol>
<h2 id="动态配置管理"><a href="#动态配置管理" class="headerlink" title="动态配置管理"></a><strong>动态配置管理</strong></h2><h3 id="核心机制：监听与长轮询改进"><a href="#核心机制：监听与长轮询改进" class="headerlink" title="核心机制：监听与长轮询改进"></a><strong>核心机制：监听与长轮询改进</strong></h3><p><strong>核心机制：监听与长轮询改进</strong></p>
<ul>
<li><strong><code>ConfigService.addListener(dataId, group, Listener)</code>:</strong> Client添加对某个配置(dataId+group)的监听器。</li>
<li><strong><code>ClientWorker</code> 与 <code>LongPollingRunnable</code>:</strong> Client端核心组件，管理监听器和长轮询任务。</li>
<li><strong>核心流程 - “长轮询改进” (Server-Center模块):</strong><ol>
<li><strong>发起长轮询 (Client):</strong> 监听线程(<code>LongPollingRunnable</code>) 发起 <strong>HTTP POST</strong> <code>/nacos/v1/cs/configs/listener</code>。请求体包含它关心的所有 <code>dataId+group</code> 及其 <code>contentMd5</code>（当前客户端本地配置内容的MD5值，用于标识版本）。<strong>关键参数: <code>Listening-Configs</code> (加密的监听配置列表)， <code>timeout</code> (长轮询超时时间, 默认30s - <code>configLongPollTimeout</code>)</strong>。</li>
<li><strong>Server端处理:</strong><ul>
<li>检查传入 <code>dataId+group</code> <strong>是否被修改过</strong>(比对Server端存储的最新 <code>contentMd5</code>)。若<strong>任一</strong>配置有变更，<strong>立即返回</strong>该变化的 <code>dataId+group</code> 给Client。</li>
<li>若<strong>无变更</strong>，Server端将此连接<strong>挂起</strong>（使用 <code>Servlet 3.0 AsyncContext</code> 异步支持），放入一个 <strong><code>Map&lt;String, List&lt;ClientLongPolling&gt;&gt;</code> 结构（Key: GroupKey&#x3D;dataId+group)</strong> 等待队列。</li>
</ul>
</li>
<li><strong>触发变更推送 (Server):</strong> 当有配置更新时，发布事件的线程 (<code>ConfigDataChangeEvent</code>)：<ul>
<li>计算新配置的 <code>contentMd5</code>。</li>
<li>查找对应 <code>GroupKey</code> 的所有挂起连接 (<code>List&lt;ClientLongPolling&gt;</code>)。</li>
<li><strong>批量响应 (Batch Push):</strong> <strong>立即向所有挂起的连接响应</strong>，携带变更的 <code>GroupKey</code>。这<strong>不是点对点UDP</strong>，而是<strong>对等待该GroupKey变更的所有客户端的长连接进行批量响应</strong>。</li>
</ul>
</li>
<li><strong>Client处理响应:</strong><ul>
<li>如果在 <code>timeout</code> (30s) 内收到了Server的响应（无论返回变更还是超时返回304），则：<ul>
<li>若返回304（<code>no change</code>），等待下一次长轮询。</li>
<li>若返回了变化的 <code>dataId+group</code>，<strong>立即发起一次HTTP GET <code>/v1/cs/configs</code></strong> 拉取该配置项的最新内容（含所有内容）。</li>
</ul>
</li>
<li>如果30秒内Server端无任何配置变更，则Server会返回 <strong>HTTP 304 Not Modified</strong>。Client收到后，稍作延迟（随机），<strong>立即发起下一次长轮询请求</strong></li>
</ul>
</li>
</ol>
</li>
<li><strong>核心优势 (vs 短轮询):</strong><ul>
<li><strong>大幅度减少无效请求：</strong> 短轮询需要客户端频繁（如每秒）查询，无论有无变更。长轮询在无变更时<strong>最大30s才有一个请求（短轮询30个）</strong>。大大节省Server资源。</li>
<li><strong>准实时：</strong> 变更发生后，通过挂起连接批量响应，能实现<strong>秒级（甚至毫秒级）</strong> 的变更通知，接近实时推送。拉取配置内容（HTTP GET）是紧随通知后的动作。</li>
<li><strong>兜底机制：</strong> 长轮询超时确保了连接不会永久挂起，提供了可靠性。<code>configLongPollTimeout</code> 是<strong>关键调优参数</strong>：设置过大，单连接占用资源久；设置过小，可能导致轮询过于频繁。默认30s是平衡点。</li>
<li><em>典型场景：微服务中动态日志级别调整。在Nacos控制台修改<code>application.yml</code>中<code>logging.level.com.example</code>的配置，<code>ConfigService</code>监听到变更，应用无需重启就能即时调整日志输出级别</em></li>
</ul>
</li>
</ul>
<h2 id="集群与一致性协议"><a href="#集群与一致性协议" class="headerlink" title="集群与一致性协议"></a>集群与一致性协议</h2><h3 id="多模式一致性协议"><a href="#多模式一致性协议" class="headerlink" title="多模式一致性协议"></a>多模式一致性协议</h3><p><em>对比Eureka、Consul等竞品的差异、脑裂问题的处理</em></p>
<p><strong>AP模式：（Distro协议）</strong>：临时实例采用自研Distro协议（异步复制），保证高可用</p>
<ul>
<li><strong>核心机制 (最终一致性)：</strong><ul>
<li><strong>注册中心场景专用(临时实例)&#x2F;配置中心默认。</strong> Distro 是 Nacos 自研的最终一致性协议。</li>
<li><strong>节点对等 &amp; 分片责任：</strong> 集群内<strong>所有节点地位平等</strong>。每个节点负责集群中<strong>一部分数据分片</strong> (基于 <code>Service Name</code>或 <code>DataID</code> 的哈希分片)。每个节点负责<strong>自己分片数据的主写和主读</strong>（对于其负责分片的写请求，该节点是事实上的“Leader”）。</li>
<li><strong>写流程：</strong><ol>
<li>Client 可以<strong>写任意节点</strong>（Server A）。</li>
<li>Server A 判断该数据<code>Key</code>（如Service Name）是否<strong>属于自己的责任分片</strong>：<ul>
<li><strong>是：</strong> 写入本地内存并<strong>立即响应Client成功</strong>。然后将写操作<strong>异步复制 (<code>DistroProtocol</code>) 给其他所有节点</strong>。复制成功与否不阻塞Client响应。</li>
<li><strong>否：</strong> Server A 将请求 <strong>重定向 (<code>redirect()</code>) 到计算出的该Key的责任节点</strong>（Server B）。由Server B负责其分片数据的处理和复制。<code>DistroConsistencyServiceImpl</code> 处理此逻辑。</li>
</ul>
</li>
</ol>
</li>
<li><strong>读流程：</strong> Client可以读任意节点。节点返回自己<strong>当前内存中</strong>的最新数据（最终一致性，可能不是全局绝对最新）。</li>
<li><strong>数据同步 (<code>DistroTask</code>):</strong> 节点间<strong>定期（秒级）互相校验全量数据摘要(<code>Digest</code>)或增量数据</strong> (<code>DistroDataProcessor</code>)。通过<strong>Gossip协议</strong>或<strong>直接点对点校验</strong>，发现差异后拉取缺失&#x2F;更新数据。保证最终数据收敛一致。<code>distro.data.sync.retryDelay</code> 和 <code>distro.data.sync.periodMs</code> 控制同步频率。</li>
<li><strong>分区容忍：</strong> 当发生网络分区时（如两个机房断开）：<ul>
<li>分区内多数派或各分区内部仍能正常读写<strong>自己责任分片</strong>的数据。</li>
<li>但<strong>跨分区的责任分片数据不可读写</strong>（Client写不属于本分区节点责任分片时会被重定向到另一个分区，因网络不通而失败）。</li>
<li>可用性主要体现在<strong>分区内部服务注册和发现的连续性</strong>，以及配置读取（可能读到旧值）上。<em>典型场景：某应用实例（Provider）在分区A注册成功，分区B的消费者暂时看不到该实例（数据未同步），但分区内消费者和生产者通信正常。分区恢复后数据自动同步。</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>适用场景：</strong> <strong>高可用性要求优先，可接受秒级（最终）数据不一致。</strong> 例如：微服务注册发现（实例临时上下线）、动态降级限流规则（能感知到即可）、绝大多数业务配置（阈值、开关等）。<em>典型场景：电商大促期间，临时扩容大量服务实例要求快速注册生效，即使有轻微延迟（毫秒到秒）也不影响整体服务调用。</em></li>
</ul>
<p><strong>CP模式：（Raft协议）</strong>：持久实例和配置数据使用Raft协议，保证强一致性</p>
<p><strong>数据写入流程</strong></p>
<ul>
<li><strong>写请求路由</strong>：所有写请求（配置发布&#x2F;服务注册）必须由 <strong>Leader 节点处理</strong>。若客户端请求发送到 Follower，Follower 会拒绝并返回 Leader 地址（重定向机制）。</li>
<li><strong>强一致性保证</strong>：<ul>
<li>Leader 将操作封装为 <strong>Raft 日志</strong>，同步复制到多数节点（N&#x2F;2+1）。</li>
<li>仅当多数节点持久化日志后，Leader 才提交日志并响应客户端成功。</li>
</ul>
</li>
<li><strong>Leader 选举</strong>：Leader 宕机后，集群进入选举状态（通常 3-10 秒），期间<strong>所有写请求阻塞</strong>，直到新 Leader 产生。</li>
</ul>
<p><strong>配置更新与拉取</strong></p>
<ul>
<li><strong>配置发布</strong>：配置变更通过 Raft 日志同步到多数节点，确保强一致。客户端通过 <strong>HTTP 长轮询</strong>（默认 30s）感知变更：无变更时请求挂起，变更时立即返回新配置。</li>
<li><strong>客户端拉取</strong>：客户端首次拉取全量配置并缓存；后续通过监听器（<code>Listener</code>）和长轮询更新本地缓存。</li>
</ul>
<p><strong>服务实例更新</strong></p>
<ul>
<li><strong>临时实例注册</strong>：需通过 Leader 写入日志并同步多数节点。若 Leader 宕机，注册请求失败（需客户端重试）。</li>
<li><strong>健康检查</strong>：实例心跳由 Leader 统一处理。若心跳超时（默认 30 秒），Leader 触发日志同步移除实例</li>
</ul>
<p><strong>对比：</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CP模式 (Raft)</strong></th>
<th><strong>AP模式 (Distro)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>一致性 (C)</strong></td>
<td><strong>强一致性</strong> (读写线性一致)</td>
<td><strong>最终一致性</strong> (短暂窗口可能读到旧数据)</td>
</tr>
<tr>
<td><strong>可用性 (A)</strong></td>
<td>选主期间<strong>写服务短暂不可用</strong>(读可用?)</td>
<td><strong>读写高可用</strong> (分区内部读写可用)</td>
</tr>
<tr>
<td><strong>分区容忍 (P)</strong></td>
<td>多数派存活可继续服务</td>
<td>分区内部能独立提供服务，分区恢复后数据同步</td>
</tr>
<tr>
<td><strong>核心协议</strong></td>
<td>Raft (Leader选举，日志复制多数派提交)</td>
<td>Distro (分片责任，重定向，异步复制，定期校验)</td>
</tr>
<tr>
<td><strong>写扩散</strong></td>
<td>Leader接收写请求，同步并行复制</td>
<td>任意节点接收，责任节点写入并异步复制，批量广播</td>
</tr>
<tr>
<td><strong>读扩散</strong></td>
<td>可能Leader读最新(或follower可读已提交?)</td>
<td>所有节点均可读本地最新(可能滞后)</td>
</tr>
<tr>
<td><strong>主节点</strong></td>
<td>有明确Leader</td>
<td>无中心Leader (按分片责任)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>强一致要求高配置、状态锁、基础服务</td>
<td>服务注册发现、高可用要求配置、容忍短暂不一致</td>
</tr>
<tr>
<td><strong>配置项</strong></td>
<td><code>nacos.core.protocol.raft.data=true</code></td>
<td><code>nacos.core.protocol.raft.data=false</code> (默认) 或 ephemeral&#x3D;true强制AP</td>
</tr>
<tr>
<td><strong>配置更新实时性</strong></td>
<td>强一致，变更立即可读</td>
<td>最终一致，读可能短暂滞后</td>
</tr>
<tr>
<td><strong>服务注册可用性</strong></td>
<td>Leader 宕机时注册失败</td>
<td>任意节点存活即可注册</td>
</tr>
<tr>
<td><strong>健康检查机制</strong></td>
<td>Leader 统一管理</td>
<td>各节点独立处理</td>
</tr>
</tbody></table>
<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><ol>
<li><p><strong>环境准备</strong></p>
<ul>
<li><strong>节点要求</strong>：至少3个节点（奇数个），避免Raft选举脑裂问题。</li>
<li><strong>依赖环境</strong>：JDK 1.8+（配置<code>JAVA_HOME</code>，避免使用系统默认JDK）。MySQL 5.7+&#x2F;8.0（持久化数据，避免使用内嵌Derby）</li>
</ul>
</li>
<li><p><strong>配置数据库</strong></p>
<ul>
<li>创建数据库<code>nacos_config</code>，执行<code>conf/nacos-mysql.sql</code>初始化表结构。</li>
<li>关键表说明：<code>config_info</code>：存储配置内容。<code>services</code>&#x2F;<code>instances</code>：服务注册信息（持久化模式使用）。</li>
</ul>
</li>
<li><p><strong>修改Nacos配置文件</strong></p>
<ul>
<li><p><strong><code>application.properties</code></strong>：<strong>注意</strong>：MySQL 8需指定时区参数<code>serverTimezone=UTC</code>。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">properties</span><br><span class="line">复制</span><br><span class="line"># 启用MySQL数据源spring.datasource.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line">db.url.0=jdbc:mysql://mysql_ip:3306/nacos_config?charset=utf8&amp;useSSL=false</span><br><span class="line">db.user=root</span><br><span class="line">db.password=your_password</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>cluster.conf</code></strong>：复制<code>cluster.conf.example</code>为<code>cluster.conf</code>，添加所有节点IP:确保所有节点配置一致。</p>
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">复制</span><br><span class="line">192.168.1.1:8848</span><br><span class="line">192.168.1.2:8848</span><br><span class="line">192.168.1.3:8848</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>启动脚本调优</strong></p>
<ul>
<li>修改<code>bin/startup.sh</code>：<ul>
<li>调整JVM内存参数（如<code>Xms2g -Xmx2g</code>，避免OOM）。</li>
<li>指定端口启动：<code>./startup.sh -p 8848</code>（避免端口冲突）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>启动与验证</strong></p>
<ul>
<li>依次启动所有节点：<code>sh bin/startup.sh</code>。</li>
<li>验证集群状态：<ul>
<li>访问<code>http://any_node_ip:8848/nacos</code>→ “集群管理”页面，所有节点状态应为<strong>UP</strong>。</li>
<li>检查日志：<code>logs/start.out</code>无报错，出现<code>Nacos started successfully in cluster mode</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>接入负载均衡</strong></p>
<ul>
<li><p>配置Nginx&#x2F;SLB，将流量分发到Nacos集群：客户端通过VIP或域名访问（如<code>nacos.example.com:8848</code>）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">复制</span><br><span class="line">upstream nacos_cluster &#123;</span><br><span class="line">    server 192.168.1.1:8848;</span><br><span class="line">    server 192.168.1.2:8848;</span><br><span class="line">    server 192.168.1.3:8848;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>网络与端口</strong></p>
<ul>
<li><p><strong>开放端口</strong>：</p>
<table>
<thead>
<tr>
<th><strong>端口</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>8848</td>
<td>客户端API及控制台</td>
</tr>
<tr>
<td>7848</td>
<td>Raft选举（CP模式）</td>
</tr>
<tr>
<td>9848</td>
<td>Distro数据同步（AP模式）</td>
</tr>
<tr>
<td>需确保节点间所有端口互通，防火墙放行<strong>25</strong>。</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>数据一致性保障</strong></p>
<ul>
<li><p><strong>模式选择</strong>：</p>
<ul>
<li>服务发现（临时实例）→ <strong>AP模式</strong>（Distro协议，高可用优先）。</li>
<li>配置管理 → <strong>CP模式</strong>（Raft协议，强一致优先）。</li>
</ul>
</li>
<li><p><strong>切换命令</strong>：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制</span><br><span class="line"><span class="comment"># 切CP模式</span></span><br><span class="line">curl -X PUT <span class="string">&#x27;http://nacos-server:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见故障排查：节点无法通信</strong>：检查端口占用（<code>ss -ntlp | grep 7848</code>）及防火墙。<strong>数据同步失败</strong>：AP模式：查看<code>naming-distro.log</code>，验证Distro同步队列。CP模式：检查<code>naming-raft.log</code>的Leader选举状态。</p>
</li>
</ul>
</li>
</ol>
<p><strong>集群脑裂如何处理？</strong></p>
<ul>
<li><strong>Raft协议</strong>：通过任期（Term）和多数派投票机制，仅允许多数派分区选举新Leader。</li>
<li><strong>预防措施</strong>：确保网络分区容忍性（如跨机房专线）、节点时钟同步</li>
</ul>
<p><strong>对比Eureka的优势？</strong></p>
<ul>
<li>功能：Nacos集成配置管理 + 服务发现，Eureka仅服务发现。</li>
<li>一致性：Nacos支持AP&#x2F;CP切换，Eureka仅AP模式。</li>
<li>健康检查：Nacos支持主动探测，Eureka依赖客户端心跳</li>
</ul>
<h2 id="自我保护和浏览治理"><a href="#自我保护和浏览治理" class="headerlink" title="自我保护和浏览治理"></a>自我保护和浏览治理</h2><h3 id="保护阈值"><a href="#保护阈值" class="headerlink" title="保护阈值"></a>保护阈值</h3><p><strong>核心原理</strong></p>
<ul>
<li><strong>问题场景</strong>：当服务实例大规模故障（如网络抖动或集群雪崩），健康实例占比骤降，剩余健康实例可能因无法承受全部流量而崩溃。</li>
<li><strong>保护逻辑</strong>：<ul>
<li><strong>阈值定义</strong>：设定一个 <code>0~1</code> 的浮点数（如 <code>0.5</code>），表示健康实例占比的最小容忍值。</li>
<li><strong>触发条件</strong>：当健康实例数&#x2F;总实例数 &lt; 保护阈值时，触发保护机制。</li>
<li><strong>行为变化</strong>：Nacos 返回<strong>全部实例</strong>（含不健康实例）给消费者，而非仅健康实例。</li>
</ul>
</li>
</ul>
<p><strong>工作流程</strong></p>
<ol>
<li><strong>监控健康状态</strong>：Nacos Server 持续检查实例心跳（临时实例）或主动探测（持久实例）。</li>
<li><strong>计算健康比例</strong>：实时统计健康实例占比。</li>
<li><strong>阈值判定</strong>：若健康比例低于阈值（如 10 个实例中仅 2 个健康，比例 <code>0.2 &lt; 0.5</code>），则触发保护。</li>
<li><strong>返回全量实例</strong>：消费者从 Nacos 获取包含不健康实例的列表，负载均衡器可能将部分流量分发到不健康实例（导致部分请求失败，但避免健康实例被压垮）。</li>
</ol>
<p><strong>作用</strong></p>
<ul>
<li><strong>牺牲部分请求，保全整体</strong>：允许部分请求失败（访问不健康实例），但避免健康实例因过载而雪崩。</li>
<li><strong>依赖持久化实例</strong>：临时实例故障后会被删除，而持久化实例（<code>ephemeral=false</code>）即使不健康仍保留在列表中，为保护阈值提供“分流底座”</li>
</ul>
<h3 id="动态DNS与权重路由"><a href="#动态DNS与权重路由" class="headerlink" title="动态DNS与权重路由"></a>动态DNS与权重路由</h3><p><strong>流量治理：动态 DNS（Dynamic DNS）</strong></p>
<p><strong>核心原理</strong></p>
<ul>
<li><strong>功能定位</strong>：将服务名解析为可动态调整的 IP 列表，支持跨集群路由。</li>
<li><strong>工作流程</strong>：<ol>
<li>客户端通过 DNS 协议查询服务名（如 <code>serviceA.default.svc</code>）。</li>
<li>Nacos 返回该服务<strong>健康实例的 IP+Port 列表</strong>（自动过滤不健康实例）。</li>
<li>DNS 响应可附加权重信息，供客户端实现加权轮询。</li>
</ol>
</li>
</ul>
<p><strong>高级路由策略</strong></p>
<ol>
<li><strong>基于权重的 DNS 解析</strong>：为不同实例 IP 分配不同权重，DNS 响应按权重比例返回 IP，实现客户端侧负载均衡。</li>
<li><strong>就近访问（Cluster-Nearby）</strong>：实例设置 <code>cluster-name</code>（如 <code>cluster-shanghai</code>）。消费者优先访问同集群实例，减少跨地域延迟。</li>
<li><strong>多级路由策略</strong>：</li>
</ol>
<p><img src="/img/article/nacos/image.png" alt="image.png"></p>
<p><strong>权重作用原理</strong></p>
<ul>
<li><strong>定义</strong>：为每个实例分配权重值（默认 <code>1.0</code>，范围 <code>0~10000</code>），控制其接收流量的比例。</li>
<li><strong>负载均衡逻辑</strong>：<ul>
<li>消费者从 Nacos 获取实例列表及权重。</li>
<li>负载均衡器（如 Ribbon、Spring Cloud LoadBalancer）按权重比例分配请求。</li>
<li><strong>公式</strong>：实例流量占比 &#x3D; 该实例权重 &#x2F; 集群总权重。</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ol>
<li><strong>性能差异化调度</strong>：高性能服务器权重设为 <code>2.0</code>，低性能设为 <code>0.5</code>，使高性能机器承担更多流量。</li>
<li><strong>灰度发布</strong>：新版本实例权重从 <code>0.1</code> 逐步提升至 <code>1.0</code>，旧版本权重从 <code>1.0</code> 降至 <code>0</code>，实现平滑迁移。</li>
<li><strong>故障隔离</strong>：疑似故障实例权重设为 <code>0</code>，使其暂时不接收流量，但不注销（便于诊断）</li>
</ol>
<p><strong>护阈值与流量治理的协同</strong></p>
<ul>
<li><strong>保护阈值触发时</strong>：权重路由与动态 DNS <strong>仍生效</strong>，但不健康实例也可能被分配流量（权重 &gt; 0 时）。</li>
<li><strong>示例</strong>：服务设置保护阈值 <code>0.3</code>，实例权重：健康实例 <code>1.0</code>，不健康实例 <code>0.5</code>。当健康比例 <code>&lt;0.3</code> 时，不健康实例参与分流（如承担 33% 流量），避免健康实例过载。</li>
</ul>
<p><strong>参考</strong></p>
<ul>
<li><strong>保护阈值设置</strong>：建议 <code>0.3~0.5</code>，过低失去保护意义，过高导致过多失败请求。</li>
<li><strong>权重管理</strong>：<ul>
<li>结合监控系统（如 Prometheus）动态调整权重。</li>
<li>永久实例权重不低于 <code>0.1</code>，确保保护阈值触发时可参与分流。</li>
</ul>
</li>
<li><strong>动态 DNS 适用场景</strong>：跨语言客户端、K8s 服务发现、多数据中心路由</li>
</ul>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>核心目标</strong></th>
<th><strong>实现方式</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>保护阈值</td>
<td>防雪崩</td>
<td>返回全量实例分流</td>
<td>大规模实例故障</td>
</tr>
<tr>
<td>权重路由</td>
<td>精细化流量调度</td>
<td>实例级权重分配 + 客户端负载均衡</td>
<td>性能优化、灰度发布、故障隔离</td>
</tr>
<tr>
<td>动态 DNS</td>
<td>跨环境服务发现</td>
<td>DNS 响应动态 IP 列表 + 权重</td>
<td>多语言接入、多集群路由</td>
</tr>
</tbody></table>
<h2 id="性能优化与场景问题"><a href="#性能优化与场景问题" class="headerlink" title="性能优化与场景问题"></a>性能优化与场景问题</h2><h3 id="注册发现侧："><a href="#注册发现侧：" class="headerlink" title="注册发现侧："></a><strong>注册发现侧：</strong></h3><ul>
<li><strong>心跳参数 (<code>heartBeatInterval</code>, <code>heartBeatTimeout</code>):</strong> 增大间隔和超时减少请求数（牺牲感知速度）。评估业务容忍度。</li>
<li><strong>UDP推送可靠性：</strong> 网络不稳定环境，可适当降低<code>pushReceiverTask</code>的间隔（但增加Server压力），或监控UDP丢包率排查。</li>
<li><strong>服务数 &amp; 实例数爆炸：</strong> 合理划分Namespace&#x2F;Group，避免单个Service下实例过多。优化应用逻辑，非必要不频繁getInstances。</li>
<li><strong><code>nacos.naming.clean.clean-contaminated-service.interval</code> &#x2F; <code>nacos.naming.clean.empty-service.interval</code>:</strong> 控制清理无实例或脏数据服务（如因复制异常）的频率，减少内存占用。</li>
</ul>
<h3 id="配置中心侧："><a href="#配置中心侧：" class="headerlink" title="配置中心侧："></a><strong>配置中心侧：</strong></h3><ul>
<li><strong><code>configLongPollTimeout</code>:</strong> 调整长轮询超时，平衡实时性和连接占用。集群压力大时可考虑略微加大（如40s）。</li>
<li><strong>批量监听:</strong> 尽可能在一个Listener监听多个<code>dataId</code>（使用 <code>dataId=xxxx*</code> 通配监听），减少长轮询连接数。</li>
<li><strong>压缩:</strong> 支持配置内容压缩传输，节省带宽。</li>
<li><strong>客户端本地缓存 (<code>LocalConfigInfoProcessor</code>):</strong> 保证即使短暂失联也能获取配置。</li>
</ul>
<h3 id="通用："><a href="#通用：" class="headerlink" title="通用："></a><strong>通用：</strong></h3><ul>
<li><strong>JVM调优:</strong> 根据节点压力调整堆大小(<code>Xms</code>, <code>Xmx</code>), G1 GC相关参数(<code>MaxGCPauseMillis</code>, <code>InitiatingHeapOccupancyPercent</code>)。</li>
<li><strong>数据库性能:</strong> 持久化场景下DB是关键瓶颈。读写分离、分库分表、优化慢SQL。</li>
<li><strong>集群规模:</strong> 合理评估节点数。CP模式建议3&#x2F;5节点；AP模式节点过多同步开销增大。<code>distro.member-change-task.worker-count</code> 调整成员变化处理线程。</li>
</ul>
<h3 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a><strong>常见问题排查</strong></h3><ul>
<li><strong>服务注册&#x2F;发现失败：</strong><ol>
<li>检查 Provider&#x2F;Consumer 端配置的 <code>nacos.addr</code> 是否正确可达。</li>
<li>查看 <strong>Nacos Server <code>/nacos/v1/ns/instance/list?serviceName=xxx</code> API 返回</strong>是否包含目标实例。</li>
<li><strong><code>ephemeral</code>判断：</strong> 临时实例检查 Provider 日志看<strong>是否打印心跳成功&#x2F;失败</strong>, 检查 Server端对应Service的内存注册表（控制台或API）。持久实例检查<strong>数据库 <code>config_info</code> &#x2F; <code>his_config_info</code>(配置历史) 或 <code>services</code>&#x2F;<code>instances</code>(服务注册)</strong> 表和<strong>Server的主动探活日志</strong>。</li>
<li>检查网络：Nacos节点间端口(7848-CP Raft, 9848-AP Distro &amp; 配置Notify, 8848-HTTP API)防火墙？Consumer订阅端口（<strong>UDP:8848+1000&#x3D;9848</strong>）是否允许入站？</li>
<li>查看 Server 日志 <code>logs/naming-raft.log</code>(CP) &#x2F; <code>naming-distro.log</code>(AP) &#x2F; <code>naming-server.log</code> 是否有异常。</li>
</ol>
</li>
<li><strong>配置不更新：</strong><ol>
<li>检查 Client 是否确实 <code>addListener</code> 并监听正确 <code>dataId+group</code>。</li>
<li><strong>抓包&#x2F;Wireshark：</strong> 查看 Client 发起的 <code>/v1/cs/configs/listener</code><strong>长轮询请求参数</strong>是否正确，<strong>Server 返回</strong>是304还是200。若返回200，Client是否立即发起<code>GET</code>拉取新内容。</li>
<li>检查控制台配置历史 (<code>config_info</code>, <code>his_config_info</code>) 确认已发布成功。</li>
<li>查看 Server <code>config-server.log</code>，有无 <code>[fixed-delay-task]</code>相关日志异常。检查 <code>server.tomcat</code>连接池（<code>maxThreads</code>, <code>minSpareThreads</code>, <code>maxConnections</code>）是否耗尽导致长轮询处理失败。</li>
<li>检查 <code>pushEmptyProtection</code> 设置是否合理（导致不该返回空时返回空？）。</li>
</ol>
</li>
<li><strong>集群脑裂&#x2F;数据不一致：</strong><ul>
<li><strong>CP模式:</strong> 检查 <code>naming-raft.log</code> 确认 <strong>Leader 唯一性</strong> 和 <strong>Leader&#x2F;Follower 任期 (<code>term</code>)</strong> 是否一致。查看 <strong>Raft 选主日志 (选举成功&#x2F;失败)</strong>，网络是否隔离少数派。</li>
<li><strong>AP模式:</strong> 使用 <code>/nacos/v1/ns/operator/distro/datum</code> &amp; <code>datums</code><strong>Distro元数据校验API</strong>检查各节点对同一Service的数据摘要(<code>Digest</code>)是否一致。观察 <code>naming-distro.log</code> 中数据同步 (<code>sync</code>, <code>verify</code>, <code>retry</code>) 日志是否频繁失败。<code>distro.failed.task.retry.delay</code>参数影响重试。根本解决：<strong>确保物理网络可靠</strong>，配置合理的节点探测超时</li>
</ul>
</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h3><ul>
<li><strong>命名规范：</strong> 强制使用<code>Namespace</code>(环境隔离：DEV&#x2F;TEST&#x2F;PROD)，善用<code>Group</code>(应用&#x2F;项目分组)。</li>
<li><strong>实例划分：</strong> 大多数微服务场景使用<strong>临时实例 (<code>ephemeral=true</code>)</strong>，利用心跳自动上下线。基础设施服务（如数据库中间件）可用持久实例+主动探活。</li>
<li><strong>配置管理：</strong><ul>
<li>敏感配置加密存储。</li>
<li>利用 <strong><code>shared-dataids</code>或<code>extension-configs</code>(Nacos Spring Cloud) 共享公共配置</strong>。</li>
<li><strong>大配置谨慎使用长轮监听</strong>，拆分小配置。</li>
<li><code>type</code> 明确指定 (yaml, properties, json)。</li>
</ul>
</li>
<li><strong>集群部署：</strong><ul>
<li><strong>AP模式（默认）用于服务发现和一般配置。</strong></li>
<li><strong>对强一致性配置使用CP模式 (<code>nacos.core.protocol.raft.data=true</code>)，部署3或5节点。</strong></li>
<li><strong>跨机房部署：AP模式使用 VIP + SLB 或</strong>部署 <strong>多个独立 AP 集群 + Sync组件</strong>（跨集群异步数据同步工具），避免脑裂。CP模式需确保多数派节点在同一可靠域内。</li>
<li><strong>持久层分离：</strong> 生产环境务必<strong>配置外部 MySQL&#x2F;PostgreSQL</strong>，避免使用内嵌 Derby。</li>
</ul>
</li>
<li><strong>客户端：</strong><ul>
<li>做好<strong>重试和降级</strong> (如配置本地缓存失效后用默认值)。</li>
<li>监听器逻辑<strong>轻量级</strong>，避免阻塞</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lavyoung.github.io">Lavigne-yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lavyoung.github.io/2025/06/09/Nacos%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/">https://lavyoung.github.io/2025/06/09/Nacos%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lavyoung.github.io" target="_blank">Lavigne-yang.Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Nacos/">Nacos</a></div><div class="post-share"><div class="social-share" data-image="/img/article/nasa_the_blue_marble.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/09/SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" title="SpringBoot启动原理解析"><img class="cover" src="/img/article/nasa_the_blue_marble.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SpringBoot启动原理解析</div></div><div class="info-2"><div class="info-item-1">核心流程  启动入口：SpringApplication.run() 创建 SpringApplication 实例，初始化 ApplicationContext（默认 AnnotationConfigApplicationContext）。 加载 META-INF/spring.factories 中的 ApplicationContextInitializer 和 ApplicationListener。   准备环境（Environment） 读取默认配置application.yml及命令行参数。 配置 Profiles``prod）。   创建并刷新 ApplicationContext 调用 AbstractApplicationContext.refresh()，核心流程： Bean 定义加载：扫描 @Component、@Service 等注解类。 Bean 实例化：通过 BeanFactory 创建单例 Bean。 依赖注入：处理 @Autowired、@Resource 等注解。 初始化回调：执行 @PostConstruct、InitializingBean...</div></div></div></a><a class="pagination-related" href="/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/" title="业务方案总结"><img class="cover" src="/img/article/nasa_the_blue_marble.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">业务方案总结</div></div><div class="info-2"><div class="info-item-1">Q：Redis和数据库的缓存一致性保证A： 方案如下：  更新数据库之后删除缓存（旁路缓存模式） 并发情况下可采用延迟双删策略 或者实现canal客户端订阅数据变更，更新缓存 适合：商品详情页场景，读多写少的场景  先更新缓存再更新数据库（异步更新）  更新缓存成功采用消息队列更新数据（消费幂等性保证） 场景：秒杀   双写操作  同时更新Redis和数据库，可以使用事务保证（分布式事务方案，事务补偿机制） 场景：积分   数据回写  优先更新缓存，缓存数据定期更新到数据库（Redis集群和持久化机制） 场景：广告计费系统，点赞    Q：分布式锁实现方案A：  本地同步锁 分布式锁setNX 设置超时时间 redission看门狗机制，读写锁 redisssion redlock 解决锁的高一致性问题  Q：如何快速定位线上OOMA：出现的原因：  一次性申请的对象数量过多：如查询返回结果过大 内存资源耗尽未释放：如何jdbc连接、文件资源 本身资源不够：jmap -heap PID 查看堆信息  方案：  预先设置-XX:+HeapDumpOnOutOfMemoryError...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Lavigne-yang</div><div class="author-info-description">专注于知识积累</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lavigne-yang"><i class="fab fa-github"></i><span>关注</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Lavigne-yang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lavyoung1325@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #22205e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如有不足，欢迎斧正[抱拳]</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%EF%BC%88%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">服务注册和发现（健康检查）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">服务注册机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">服务发现流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">健康检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">动态配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E7%9B%91%E5%90%AC%E4%B8%8E%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%94%B9%E8%BF%9B"><span class="toc-number">2.1.</span> <span class="toc-text">核心机制：监听与长轮询改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">集群与一致性协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.</span> <span class="toc-text">多模式一致性协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-number">3.2.</span> <span class="toc-text">集群部署</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E5%92%8C%E6%B5%8F%E8%A7%88%E6%B2%BB%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">自我保护和浏览治理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E9%98%88%E5%80%BC"><span class="toc-number">4.1.</span> <span class="toc-text">保护阈值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81DNS%E4%B8%8E%E6%9D%83%E9%87%8D%E8%B7%AF%E7%94%B1"><span class="toc-number">4.2.</span> <span class="toc-text">动态DNS与权重路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">性能优化与场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%E4%BE%A7%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">注册发现侧：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BE%A7%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">配置中心侧：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%EF%BC%9A"><span class="toc-number">5.3.</span> <span class="toc-text">通用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">5.4.</span> <span class="toc-text">常见问题排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.5.</span> <span class="toc-text">最佳实践</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/09/Nacos%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/" title="Nacos基本原理（一）"><img src="/img/article/nasa_the_blue_marble.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nacos基本原理（一）"/></a><div class="content"><a class="title" href="/2025/06/09/Nacos%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/" title="Nacos基本原理（一）">Nacos基本原理（一）</a><time datetime="2025-06-09T12:14:21.000Z" title="发表于 2025-06-09 20:14:21">2025-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/09/SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" title="SpringBoot启动原理解析"><img src="/img/article/nasa_the_blue_marble.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot启动原理解析"/></a><div class="content"><a class="title" href="/2025/06/09/SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" title="SpringBoot启动原理解析">SpringBoot启动原理解析</a><time datetime="2025-06-09T12:14:21.000Z" title="发表于 2025-06-09 20:14:21">2025-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/" title="业务方案总结"><img src="/img/article/nasa_the_blue_marble.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="业务方案总结"/></a><div class="content"><a class="title" href="/2025/05/28/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/" title="业务方案总结">业务方案总结</a><time datetime="2025-05-28T09:24:23.000Z" title="发表于 2025-05-28 17:24:23">2025-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/11/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/" title="算法热题（二）"><img src="/img/default_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法热题（二）"/></a><div class="content"><a class="title" href="/2025/04/11/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/" title="算法热题（二）">算法热题（二）</a><time datetime="2025-04-11T09:24:23.000Z" title="发表于 2025-04-11 17:24:23">2025-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/28/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/" title="算法热题（一）"><img src="/img/default_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法热题（一）"/></a><div class="content"><a class="title" href="/2025/03/28/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/" title="算法热题（一）">算法热题（一）</a><time datetime="2025-03-28T09:24:23.000Z" title="发表于 2025-03-28 17:24:23">2025-03-28</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2022 - 2025 By Lavigne-yang</span></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://Lavigne-yang.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Lavigne-yang/giscus_comments',
      'data-repo-id': 'R_kgDOOyjQAA',
      'data-category-id': 'DIC_kwDOOyjQAM4Cqumv',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="https://cdn.bootcdn.net/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.js"></script></div></body></html>